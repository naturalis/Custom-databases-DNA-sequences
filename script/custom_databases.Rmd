---
title: "Custom Databases: Classification & Analyses"
author: "Bastiaan"
date: "16 February 2021"
output: html_document
runtime: shiny
---

Introduction
------------

The following R markdown file performs the steps needed to:

1. Create a data structure capable of providing highly visual representations and at the
same time maintaining integrity of each data setâ€™s origin.
2. Search out and visualize the overlap / gaps between the obtained Public Sequence Data
(BOLD) and a reference provided by the Naturalis Biodiversity center, in correlation to
the NSR.
3. Assess the quality and reliability of public sequence data.

The following libraries need to be loaded:

```{r libraries, include=FALSE, message=FALSE, warning=FALSE}
library(rmarkdown)
library(taxizedb)
library(myTAI)
library(tidyr)
library(shiny)
library(DT)
library(plyr)
library(dplyr)
library(d3Tree)
library(billboarder)
library(nbaR)
```

In addition, here We define the global variables that we will reuse throughout
the code:

```{r globals, include=FALSE}
# This should define the root folder of the local copy of the git repository at:
# https://github.com/naturalis/Custom-databases-DNA-sequences, which is
# automatically defined correctly if we run the present code from within a
# local clone of the repo and have set the working directory to the script
# source (in RStudio: Session > Set working directory > To source file location)
REPO_HOME <- paste(dirname(getwd()), sep = "")
```

### Load data

We now load the following data sets:

1. Reference Data Set (NSR),
2. Obtained Public Sequence Data (BOLD),
3. List of Marker Codes,
4. List of Public Databases

Both the Reference Data Set (1) and the Obtained Public Sequence Data (2) are
output from the [script](../script/custom_databases.py)

```{r datasets, include=FALSE}
# Load species from the NSR file
species.file <- sprintf('%s/results/nsr_species.csv', REPO_HOME)
species <- read.csv(species.file)

# Load public sequence data
# Set missing values to na
bold.file <- sprintf('%s/data/FASTA_files/match.tsv', REPO_HOME)
bold <- read.csv(bold.file, header=TRUE, sep="\t", row.names=NULL,
                 na.strings=c(""," ","NA"))

# Load marker data set
markers.file <- sprintf('%s/results/markers.csv', REPO_HOME)
markers <- read.csv(markers.file, header=TRUE, sep=",")

# Load database data set
databases.file <- sprintf('%s/results/databases.csv', REPO_HOME)
databases <- read.csv(databases.file, header=TRUE, sep=",")
```

### Classification

Ideally, a full taxonomic hierarchy of species would be used as a reference data set. As
the NSR export only held the scientific names of all species of interest, the assigned
identification number of each record will be used to obtain their higher taxa.


### Additional taxonmy
The ability to divert to another taxonomy could prove useful in certain situations. 
Classification of species will hence be extrated from a database of choice for later use.

```{r classification, include=FALSE}
# Download taxonomic database (options: ncbi, itis, gbif, col, wfo)
# Used data source: NCBI
db_download_ncbi()

# Load species names from the NSR data set
taxidIn <- species[, "species_name"]

# Match species names to NCBI taxon IDs
taxidOut <- taxizedb::name2taxid(taxidIn, db="ncbi", out_type="summary")

# Isolate taxon IDs from output, save as vector
treeIn <- as.vector(taxidOut$id)

# Retrieve taxonomic hierarchy for each taxon ID
treeOut <- taxizedb::classification(treeIn, db="ncbi", row=1, verbose=FALSE)

# Parse out the taxonomy levels/factors that you require
taxdata = data.frame()
for(x in 1:length(treeOut)){
  tryCatch({
    c.phylum=filter(treeOut[[x]], rank =="phylum")$name
    c.class=filter(treeOut[[x]], rank =="class")$name
    c.order=filter(treeOut[[x]], rank =="order")$name
    c.family=filter(treeOut[[x]], rank =="family")$name
    c.genus=filter(treeOut[[x]], rank =="genus")$name
    c.species=filter(treeOut[[x]], rank =="species")$name
    c.taxID=filter(treeOut[[x]], rank =="species")$id
    
    row <- data.frame(cbind(phylum=c.phylum,class=c.class,order=c.order,
                            family=c.family,genus=c.genus,node_name=c.species,tax_id=c.taxID))
    taxdata <- bind_rows(taxdata, row)
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}

# Match hierarchies to NSR species names by taxon IDs
# Accounting for use of synonym names within NCBI
taxdata <- unique(taxdata)

taxdata_full <- left_join(taxidOut, taxdata, by=c("id" = "tax_id")) %>%
  left_join(., species, by=c("name" = "species_name")) %>%
  .[, c(2,9,3,4,5,6,7,1,8)] # Reaarange columns

# Adjust Header
names(taxdata_full) <- c("tax_id", "species_id", "phylum", "class", "order", "family",
                         "genus", "species", "node_name")

# Write taxonomic data to file
write.csv(taxdata_full, file=sprintf('%s/results/taxdata.csv', REPO_HOME),
          row.names=FALSE)

# Clean-up
rm(c.phylum, c.class, c.order, c.family, c.genus, c.species, c.taxID, x, row, taxdata)
```

### Create data structure

Now we will consolidate the various data sets, creating a more streamlined
data structure which allows us to track information between each source.

```{r combine, include=FALSE}
# Joining the initial loaded data sets (NSR Species & BOLD) on common data intersections
# Subsequently, change out markercode for marker names
species_markers <- right_join(species, bold[c("species_name","markercode","sequenceID",
                                              "identification_reference")],
                              by=c("species_name", "identification_reference")) %>%
  right_join(., markers, by=c("markercode" = "marker_name"))

# Formatting
species_markers <- within(species_markers, {
  #Remove obsolete columns
  species_name <- NULL
  markercode <- NULL
  identification_reference <- NULL
  
  # Add unique prefix and database ID (in case of BOLD: "1")
  sm_id <- seq.int(nrow(species_markers))
  database_id <- 1
}) %>% .[, c(5,1,4,3,2)] %>% .[complete.cases(.[ , 2]),] # Rearrange and remove NAs

# Write data as csv to output folder
write.csv(species_markers, file=sprintf('%s/results/species_markers.csv',
                                        REPO_HOME),row.names=FALSE)

# Save workspace image
save.image(sprintf('%s/script/workspace.RData', REPO_HOME))
```

### Load Tree

To perform an analyses on our species we now load the tree for our reference data set. This
is their complete tree populated with our collected data, where we seek out overlap / gaps
between the two.

```{r tree-data, include=FALSE}
# Dataframe: Get backbone, marker names, and database for each species
vis.tree <- inner_join(species, taxdata_full[c(2:7)], by=c("species_id")) %>%
  left_join(., species_markers[c("species_id","database_id", "marker_id")],
            by=c("species_id")) %>%
  left_join(., markers, by=c("marker_id")) %>%
  left_join(., databases, by=c("database_id"))

# Formatting: Remove obsolete rows
vis.tree <- within(vis.tree, {
  species_id <- NULL
  identification_reference <- NULL
  marker_id <- NULL
  database_id <- NULL
}) %>% .[, c(2,3,4,5,6,1,7,8)] # Rearrange columns

# Add count
vis.tree <- vis.tree %>% group_by_all() %>% summarise(.groups="keep", counts = n())

# Set non matching species to count 0
vis.tree <- within(vis.tree, {
  f <- is.na(marker_name) == TRUE
  counts[f] <- 0
  f <- NULL
})
```

### Perform visualisation

Compute and draw reactive shiny filters through collapsible d3js tree

```{r tree-visualisation}
# Define tree data ----
m=vis.tree%>%data.frame%>%mutate(NEWCOL=NA)%>%distinct

# Define UI for application ----
ui <- fluidPage(
  fluidRow(
    column(6,
           uiOutput("Hierarchy"),
           tableOutput("clickView"),
           d3treeOutput(outputId="d3", height="800px")
    ),
    column(6,
           "Reactive Table",
           div(DT::dataTableOutput(outputId="table"),
               style = "font-size:80%")
    )
  ),

  hr(),

  fluidRow(
    column(8,billboarderOutput(outputId="billboarder")
    ),
    column(4,billboarderOutput(outputId="markerPie"))
  )
)

# Define server logic ----
server <- function(input, output, session) {
  
  # Tree Hierarchy ----
  output$Hierarchy <- renderUI({
    Hierarchy=names(m)
    Hierarchy=head(Hierarchy,-1)
    selectizeInput("Hierarchy","Tree Hierarchy",
                   choices = Hierarchy,multiple=T,selected = Hierarchy,
                   options=list(plugins=list('drag_drop','remove_button')))
  })
  
  # Observer ----
  network <- reactiveValues()
  
  observeEvent(input$d3_update,{
    network$nodes <- unlist(input$d3_update$.nodesData)
    activeNode<-input$d3_update$.activeNode
    if(!is.null(activeNode)) network$click <- jsonlite::fromJSON(activeNode)
  })
  
  observeEvent(network$click,{
    output$clickView<-renderTable({
      as.data.frame(network$click)
    },caption='Last Clicked Node',caption.placement='top')
  })
  
  
  TreeStruct=eventReactive(network$nodes,{
    df=m
    if(is.null(network$nodes)){
      df=m
    }else{
      
      x.filter=tree.filter(network$nodes,m)
      df=ddply(x.filter,.(ID),function(a.x){m%>%filter_(.dots = list(a.x$FILTER))%>%distinct})
    }
    df
  })
  
  # Render tree
  observeEvent(input$Hierarchy,{
    output$d3 <- renderD3tree({
      if(is.null(input$Hierarchy)){
        p=m
      }else{
        p=m%>%select(one_of(c(input$Hierarchy,"NEWCOL")))%>%unique
      }
      
      d3tree(data = list(root = df2tree(struct = p,rootname = 'm'), layout = 'collapse'),
             activeReturn = c("phylum", "class", "order", "family", "genus", "species_name",
                              "counts", "marker_name", "database_name" ))
    })
  })
  
  observeEvent(network$nodes,{
    output$results <- renderPrint({
      str.out=''
      if(!is.null(network$nodes)) str.out=tree.filter(network$nodes,m)
      return(str.out)
    })    
  })
  
  # Reactive table
  output$table <- DT::renderDataTable(expr = {
    TreeStruct()%>%select(-NEWCOL)
  },
  options=list(scrollX=T,title="Reactive Table")
  )

  # Grahps ----
  output$billboarder <- renderBillboarder(expr = {
    dfActive <- TreeStruct()%>%select(-NEWCOL)
    nsrTotal <- unlist(lapply(dfActive[1:6], function(x) length(unique(x))))
    
    boldActive <- subset(dfActive,database_name=="BOLD")
    boldTotal <- unlist(lapply(boldActive[1:6], function(x) length(unique(x))))
    boldCov <- as.vector(boldTotal / nsrTotal * 100)
    
    vis.cov <- data.frame(
      taxa = paste(names(m)[1:6]),
      bold_total = boldCov
    )
    
    # Barchart Taxa
    billboarder() %>%
      bb_barchart(
        data = vis.cov[, c("taxa", "bold_total")]
      ) %>%
      bb_data(
        names = list(bold_total = "bold")
      ) %>%
      bb_y_grid(show = TRUE) %>%
      bb_y_axis(tick = list(format = suffix("%")),
                label = list(text = "Percentage of taxa covered", position = "outer-top")) %>%
      bb_legend(position = "inset", inset = list(anchor = "top-right")) %>%
      bb_labs(title = "Coverage of taxa")
  })
  
  # Marker Pie Chart
  output$markerPie <- renderBillboarder(expr = {
    dfActive <- TreeStruct()%>%select(-NEWCOL)
    vis.marker <- setNames(aggregate(dfActive$counts, list(dfActive$marker_name),
                                     FUN=sum), c("marker_name", "counts"))
    
    billboarder() %>%
      bb_piechart(data = vis.marker) %>%
      bb_labs(title = "Share of markers")
  })
  
}

shinyApp(ui, server)
```
