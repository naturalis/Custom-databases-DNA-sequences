---
title: "Custom Databases Analyses"
author: "Bastiaan"
date: "11 January 2021"
output: html_document
---

Introduction
------------

The following R markdown file performs the steps needed to search out
and visualize overlap / gaps between obtained public sequence data
(using the custom_databases.py script) and its reference by the Dutch
Species Register.

The following libraries and scripts need to be loaded:

```{r libraries, include=FALSE}
library(rmarkdown)
library(taxize)
library(myTAI)
library(dplyr)
library(tidyr)
library(collapsibleTree)
library(shiny)
library(DT)
library(plyr)
library(dplyr)
library(d3Tree)
```

In addition, We define the global variables that allow us to locate our
data:

```{r globals, include=FALSE}
# This should define the root folder of the local copy of the git repository at: https://github.com/naturalis/Custom-databases-DNA-sequences, which is
# automatically defined correctly if we run the present code from within a
# local clone of the repo and have set the working directory to the script
# source (in RStudio: Session > Set working directory > To source file location)

REPO_HOME <- paste(dirname(getwd()), sep = "")
```

### Reference Data (NSR)

Ideally a full taxonomic hierarchy of species from the NSR would be used
as reference. As only the scientific names has been given, classification
of these species can be extrated from a database of choice. Records will
be parsed into a dataframe.

```{r NSR, include=FALSE}
# Locate NSR species
NSR_Species <- sprintf('%s/data/NSR_exports/NSR_species.txt', REPO_HOME)
nsr_lst <- read.csv(NSR_Species, header=FALSE)

# Extrat taxonomic classification
# Change DB to either ncbi, itis, gbif, bold
nsr_lstoutput <- apply(nsr_lst, 1, function(x) classification(sci_id=x, db="bold", rows=1))

# Parse out the taxonomy levels that you require
nsr_ldata <- unlist(nsr_lstoutput,recursive=FALSE,use.names=TRUE)
df_nsr <- tibble(names = names(nsr_ldata), nsr_ldata) %>% 
  unnest() %>% 
  filter(rank %in% c("phylum","class","order","family","genus","species")) %>% 
  select(-id) %>% 
  spread(rank, name) %>% 
  select(name = names, phylum, class, order, family, genus, species)
df_nsr$name <- NULL
```

### Public Sequence Data (BOLD)

We now load the list of taxa for the obtained public sequence data.

```{r BOLD, include=FALSE}
bold.file <- sprintf('%s/data/FASTA_files/match.fasta', REPO_HOME)

# Taxa to table
df_bold <- read.csv(bold.file, sep = "\t", row.names=NULL)[c("phylum_name","class_name","order_name","family_name","genus_name","species_name")]
```

### Counting coverage

Calculating the coverage of the public sequence data against its reference.

```{r Coverage, include=FALSE}
coverage <- as.data.frame(table(factor(df_bold$species_name,levels=unique(df_nsr$species))))
colnames(coverage) <- c("species","bold_records")

df3 <- dplyr::left_join(df_nsr, coverage, by = "species")
```

### Draw Tree

Computing and drawing a collapsible tree, including reactive table.

```{r include=FALSE}
m=df3%>%data.frame%>%mutate(NEWCOL=NA)%>%distinct


ui <- fluidPage(
    fluidRow(
      column(6,
             uiOutput("Hierarchy"),
             tableOutput("clickView"),
             d3treeOutput(outputId="d3", height="800px")
             
             
      ),
      column(6,
             "Reactive Table",
             div(DT::dataTableOutput(outputId="table"),
                 style = "font-size:80%")
             )
      )
  )

server <- function(input, output, session) {
  
  #SearchTree----
  
  output$Hierarchy <- renderUI({
    Hierarchy=names(m)
    Hierarchy=head(Hierarchy,-1)
    selectizeInput("Hierarchy","Tree Hierarchy",
                   choices = Hierarchy,multiple=T,selected = Hierarchy,
                   options=list(plugins=list('drag_drop','remove_button')))
  })
  
  network <- reactiveValues()
  
  observeEvent(input$d3_update,{
    network$nodes <- unlist(input$d3_update$.nodesData)
    activeNode<-input$d3_update$.activeNode
    if(!is.null(activeNode)) network$click <- jsonlite::fromJSON(activeNode)
  })
  
  observeEvent(network$click,{
    output$clickView<-renderTable({
      as.data.frame(network$click)
    },caption='Last Clicked Node',caption.placement='top')
  })
 
  
  TreeStruct=eventReactive(network$nodes,{
    df=m
    if(is.null(network$nodes)){
      df=m
    }else{
      
      x.filter=tree.filter(network$nodes,m)
      df=ddply(x.filter,.(ID),function(a.x){m%>%filter_(.dots = list(a.x$FILTER))%>%distinct})
    }
    df
  })
  
  observeEvent(input$Hierarchy,{
    output$d3 <- renderD3tree({
      if(is.null(input$Hierarchy)){
        p=m
      }else{
        p=m%>%select(one_of(c(input$Hierarchy,"NEWCOL")))%>%unique
      }
      
     d3tree(data = list(root = df2tree(struct = p,rootname = 'df3'), layout = 'collapse'),activeReturn = c("phylum", "class", "order", "family", "genus", "species","bold_records"),height = 18)
    })
})
  
  observeEvent(network$nodes,{
    output$results <- renderPrint({
      str.out=''
      if(!is.null(network$nodes)) str.out=tree.filter(network$nodes,m)
      return(str.out)
    })    
  })

  output$table <- DT::renderDataTable(expr = {
    TreeStruct()%>%select(-NEWCOL)
  },
  options=list(scrollX=T,title="Reactive Table")
  )

}
  
shinyApp(ui, server)
```