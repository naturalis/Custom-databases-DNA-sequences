---
title: "Custom Databases: Classification & Analyses"
author: "Bastiaan"
date: "23 February 2021"
output: html_document
runtime: shiny
---

Introduction
------------

The following R markdown file performs the steps needed to:

1. Create a data structure capable of providing highly visual representations and at the
same time maintaining integrity of each data set’s origin.
2. Search out and visualize the overlap / gaps between the obtained Public Sequence Data
(BOLD) and a reference provided by the Naturalis Biodiversity center, in correlation to
the NSR.
3. Assess the quality and reliability of obtained public sequence data.

The following libraries need to be loaded:

```{r libraries, include=FALSE, message=FALSE, warning=FALSE}
library(rmarkdown)
library(taxizedb)
library(myTAI)
library(tidyr)
library(shiny)
library(DT)
library(plyr)
library(dplyr)
library(d3Tree)
library(billboarder)
library(nbaR)
```

In addition, here We define the global variables that we will reuse throughout
the code:

```{r globals, include=FALSE}
# This should define the root folder of the local copy of the git repository at:
# https://github.com/naturalis/Custom-databases-DNA-sequences, which is
# automatically defined correctly if we run the present code from within a
# local clone of the repo and have set the working directory to the script
# source (in RStudio: Session > Set working directory > To source file location)
REPO_HOME <- paste(dirname(getwd()), sep = "")
```

### Load data

We now load the following data sets:

1. Reference Data Set (NSR),
2. Obtained Public Sequence Data (BOLD),
3. List of Marker Codes,
4. List of Public Databases

Both the Reference Data Set (1) and the Obtained Public Sequence Data (2) are
output from the [script](../script/custom_databases.py)

```{r datasets, include=FALSE}
## Load species and synonyms from the NSR files
nsrSpecies.file <- sprintf('%s/results/nsr_species.csv', REPO_HOME)
nsrSpecies <- read.csv(nsrSpecies.file)

nsrSynonyms.file <- sprintf('%s/data/NSR_exports/synonyms_extract.csv', REPO_HOME)
nsrSynonyms <- read.csv(nsrSynonyms.file)

## Load public sequence data
## (Set missing values to na)
bold.file <- sprintf('%s/data/FASTA_files/match.tsv', REPO_HOME)
bold <- read.csv(bold.file, header=TRUE, sep="\t", row.names=NULL,
                 na.strings=c(""," ","NA"))

## Load marker data set
markers.file <- sprintf('%s/results/markers.csv', REPO_HOME)
markers <- read.csv(markers.file, header=TRUE, sep=",")

## Load database data set
databases.file <- sprintf('%s/results/databases.csv', REPO_HOME)
databases <- read.csv(databases.file, header=TRUE, sep=",")
```

### NSR Backbone

Ideally, a full taxonomic hierarchy of species would be used as a reference data set. As
the NSR export only held the scientific names of all species of interest, the Netherlands
Biodiversity API will be queried to obtain their higher taxa.

```{r nsrBackbone, include=FALSE}
## Taxonomy to retrieve the hierarchy from
nsrIn <- tolower(nsrSpecies[, "species_name"])

## Query NSR taxon records (duration: ~40m)
queryParams <- list("sourceSystem.code"="NSR")
nsrSpecimens <- data.frame()
for(x in 1:length(nsrIn)){
  queryParams[["acceptedName.scientificNameGroup"]] <- nsrIn[x]
  nsrSpecimens <- bind_rows(nsrSpecimens, taxon_query(queryParams))
}

## Access required taxonomic fields
nsrBackbone = data.frame()
for(x in 1:nrow(nsrSpecimens)){
  tryCatch({
    c.id=nsrSpecimens$id[x]
    c.kingdom=nsrSpecimens$defaultClassification$kingdom[x]
    c.phylum=nsrSpecimens$defaultClassification$phylum[x]
    c.class=nsrSpecimens$defaultClassification$className[x]
    c.order=nsrSpecimens$defaultClassification$order[x]
    c.family=nsrSpecimens$defaultClassification$family[x]
    c.genus=nsrSpecimens$defaultClassification$genus[x]
    c.species=nsrSpecimens$acceptedName$specificEpithet[x]
    c.authority=nsrSpecimens$acceptedName$authorshipVerbatim[x]

    row <- data.frame(cbind(tax_id=c.id,kingdom=c.kingdom,phylum=c.phylum,class=c.class,
                        order=c.order,family=c.family,genus=c.genus,
                        species=paste(c.genus,c.species),identification_reference=c.authority))
    nsrBackbone <- bind_rows(nsrBackbone, row)
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}

## Remove parenthesis around the authority for consistency across data sets
nsrBackbone$identification_reference = gsub("[()]", "", nsrBackbone$identification_reference)

## Match to species ID
nsrBackbone <- left_join(nsrBackbone, nsrSpecies[1:2], by=c("species"="species_name")) %>%
  .[,c(1,10,2,3,4,5,6,7,8,9)]

## Write NSR data to file
write.csv(nsrBackbone, file=sprintf('%s/results/tree_nsr.csv', REPO_HOME),
          row.names=FALSE)

## Clean up query variables
rm(x, row, queryParams, list = ls()[grep("^c.", ls())])
```

### Naturalis Coverage

To determine the overlap / gaps between the obtained public sequence data and our reference
at the Naturalis Biodiversity Center, in relation to the NSR, we now query the Naturalis
specimen records (using the Netherlands Biodiversity API) to obtain their coverage of species.

```{r natCoverage, include=FALSE}
## Taxonomy to retrieve the hierarchy from
natIn <- unique(gsub("([A-Za-z]+).*", "\\1", nsrSpecies$species_name))

## Query Naturalis specimen records (duration: ~20m)
queryParams <- list()
natSpecimens <- data.frame()
for(x in 1:length(natIn)){
  queryParams[["identifications.scientificName.genusOrMonomial"]] <- natIn[x]
  natSpecimens <- bind_rows(natSpecimens, specimen_query(queryParams))
}

## Access required taxonomic fields
natSpecies = data.frame()
for(x in 1:nrow(natSpecimens)){
  tryCatch({
    c.genus=natSpecimens$identifications[[x]]$defaultClassification$genus
    c.species=natSpecimens$identifications[[x]]$defaultClassification$specificEpithet
    c.count=natSpecimens$numberOfSpecimen[[x]]
    c.id=natSpecimens$id[[x]]

    row <- data.frame(cbind(species=paste(c.genus,c.species),counts=c.count,sequenceID=c.id))
    natSpecies <- bind_rows(natSpecies, row)
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}

## Remove NAs, sum unique species record counts
natSpecies <- natSpecies[complete.cases(natSpecies), ]
natSpecies$counts <- as.numeric(as.character(natSpecies$count))
natSpecies <- aggregate(counts ~ species+sequenceID, data=natSpecies, FUN=sum)

## Prepare to account for synonymous names
nsrSynonyms$species <- gsub("([A-Za-z]+.[a-z]+).*", "\\1", nsrSynonyms$Synonym)
nsrSynonyms$Taxon <- gsub("([A-Za-z]+.[a-z]+).*", "\\1", nsrSynonyms$Taxon)

## Match and adopt synonymous names
natSpecies <- left_join(natSpecies, nsrSynonyms[2:3],by=c('species'))
natSpecies$Taxon <- coalesce(natSpecies$Taxon, natSpecies$species)
natSpecies <- natSpecies[,c(4,3,2)]
colnames(natSpecies)[1] <- "species_name"

## Match species against the NSR
natCoverage <- merge(natSpecies, nsrSpecies[c(2:3)], by="species_name")

## Clean up query variables
rm(x, row, queryParams, list = ls()[grep("^c.", ls())])
```

### Additional taxonomy

The ability to divert to another taxonomy could prove useful in certain situations.
Classification of species will hence be extrated from a database of choice for later use.

```{r tree_ncbi, include=FALSE}
## Download taxonomic database (options: ncbi, itis, gbif, col, wfo)
## Used data source: NCBI
db_download_ncbi()

## Load species names from the NSR data set
taxidIn <- nsrSpecies[, "species_name"]

## Match species names to NCBI taxon IDs
taxidOut <- taxizedb::name2taxid(taxidIn, db="ncbi", out_type="summary")

## Isolate taxon IDs from output, save as vector
treeIn <- as.vector(taxidOut$id)

## Retrieve taxonomic hierarchy for each taxon ID
treeOut <- taxizedb::classification(treeIn, db="ncbi", row=1, verbose=FALSE)

## Parse out the taxonomy levels/factors that you require
taxdata = data.frame()
for(x in 1:length(treeOut)){
  tryCatch({
    c.tax_id=filter(treeOut[[x]], rank =="species")$id
    c.parent_tax_id=filter(treeOut[[x]], rank =="genus")$id
    c.rank=filter(treeOut[[x]], rank =="species")[[2]]
    c.name=filter(treeOut[[x]], rank =="species")$name

    row <- data.frame(cbind(tax_id=c.tax_id,parent_tax_id=c.parent_tax_id,
                            rank=c.rank, name=c.name))
    taxdata <- bind_rows(taxdata, row)
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
taxdata <- unique(taxdata)

## Match hierarchies to NSR species names by taxon IDs
## (Accounting for use of synonymous names within NCBI)
tree_ncbi <- left_join(taxdata, taxidOut, by=c("tax_id"="id"),
                       suffix=c("","_nsr")) %>%
  left_join(., nsrSpecies[1:2], by=c("name_nsr" = "species_name")) %>%
  .[, c(1,6,2,3,4)] # Reaarange columns, drop 'name_nsr' column
tree_ncbi <- tree_ncbi[complete.cases(tree_ncbi$species_id), ]

## Write NCBI data to file
write.csv(tree_ncbi, file=sprintf('%s/results/tree_ncbi.csv', REPO_HOME),
          row.names=FALSE)

## Clean up query variables
rm(x, row, list = ls()[grep("^c.", ls())])
```

### Create data structure

Now we will consolidate the various data sets, creating a more streamlined
data structure while maintaining the integrity of each data set’s origin.

```{r species_markers, include=FALSE}
## Match the NSR species names with the obtained (BOLD) public sequence data
## Subsequently, fetch the associated ID for each markercode
species_markers <- right_join(nsrSpecies, bold[c("species_name","markercode","sequenceID",
                                                 "identification_reference")],
                              by=c("species_name", "identification_reference")) %>%
  right_join(., markers, by=c("markercode" = "marker_name"))
species_markers$database_id <- 1
species_markers$sequenceID <- as.character(species_markers$sequenceID)

## Prepare Naturalis merge
naturalis <- left_join(natCoverage, nsrSpecies, by=c("species_name",
                                                     "identification_reference"))
naturalis$database_id <- 0
naturalis$marker_id <- 0
naturalis$counts <- NULL

## Merge Naturalis records
species_markers <- merge(species_markers, naturalis,
                         by=c("species_id","identification_reference","sequenceID",
                              "database_id","marker_id","species_name"), all=TRUE)

## Add a unique identifier for each record
species_markers <- within(species_markers, {
  species_marker_id <- seq.int(nrow(species_markers))
}) %>%
  .[, c(8,1,4,5,3)] %>% # Remove obsolete and rearrange columns
  .[complete.cases(.[ , 2]),] # Omit empty records (NAs)

## Write data as csv to output folder
write.csv(species_markers, file=sprintf('%s/results/species_markers.csv',
                                        REPO_HOME),row.names=FALSE)
```

### Load Tree

To perform an analyses on our species we now load the backbone of the NSR. This is their
complete tree, populated with our collected data. Here where we seek out overlap / gaps
between Naturalis and our obtained Public Sequence Data .

```{r tree, include=FALSE}
## Get classification for each obtained record
tree <- left_join(nsrSpecies[1], nsrBackbone[c(2:9)], by=c("species_id")) %>%
  left_join(., species_markers[c("species_id","database_id", "marker_id")],
            by=c("species_id")) %>%
  left_join(., markers, by=c("marker_id")) %>%
  left_join(., databases, by=c("database_id"))

## Sum count of unique records
tree <- tree %>% group_by_all() %>% summarise(.groups="keep", counts = n())

## Set count for non matching species to NA
tree <- within(tree, {
  f <- is.na(database_name) == TRUE
  counts[f] <- NA
  f <- NULL
})

## Remove obsolete and rearrange columns
tree <- tree[,c(2,3,4,5,6,7,8,11,12,13)]

## Save workspace image
save.image(sprintf('%s/script/workspace.RData', REPO_HOME))
```

### Perform visualisation

Compute and draw reactive shiny filters through collapsible d3js tree. The server observes
the d3 collapsible tree library and its real-time layout. Data transferred back to Shiny is
mapped to a series of logical expressions to create the reactive filters. Additional figures
aid the visualization of data.

```{r tree-visualisation}
## Define tree data ----
m=tree%>%data.frame%>%mutate(NEWCOL=NA)%>%distinct

## Define UI for application ----
ui <- fluidPage(
  fluidRow(
    column(6,
           uiOutput("Hierarchy"),
           tableOutput("clickView"),
           d3treeOutput(outputId="d3", height="800px")
    ),
    column(6,
           "Reactive Table",
           div(DT::dataTableOutput(outputId="table"),
               style = "font-size:80%")
    )
  ),

  hr(),

  fluidRow(
    column(8,billboarderOutput(outputId="billboarder")
    ),
    column(4,billboarderOutput(outputId="markerPie"))
  )
)

## Define server logic ----
server <- function(input, output, session) {

  # Tree Hierarchy ----
  # Enable hierarchy order of the levels to be switched through its input box objects
  output$Hierarchy <- renderUI({
    Hierarchy=names(m)
    Hierarchy=head(Hierarchy,-1)
    selectizeInput("Hierarchy","Tree Hierarchy",
                   choices = Hierarchy,multiple=T,selected = Hierarchy,
                   options=list(plugins=list('drag_drop','remove_button')))
  })

  # Observer ----
  # The 'activeNode' observer returns meta data of the last clicked node
  network <- reactiveValues()

  observeEvent(input$d3_update,{
    network$nodes <- unlist(input$d3_update$.nodesData)
    activeNode<-input$d3_update$.activeNode
    if(!is.null(activeNode)) network$click <- jsonlite::fromJSON(activeNode)
  })

  observeEvent(network$click,{
    output$clickView<-renderTable({
      as.data.frame(network$click)
    },caption='Last Clicked Node',caption.placement='top')
  })

  # If a node is clicked it is interpreted as being of interest and a logical
  # expression is created to return it and its children.
  # If specific siblings are clicked, and opened, then the non-clicked siblings are not
  # returned.
  TreeStruct=eventReactive(network$nodes,{
    df=m
    if(is.null(network$nodes)){
      df=m
    }else{

      x.filter=tree.filter(network$nodes,m)
      df=ddply(x.filter,.(ID),function(a.x){m%>%filter_(.dots = list(a.x$FILTER))%>%distinct})
    }
    df
  })

  # Render tree ----
  # Meta data from the observer is inputed in the d3tree call in the activeReturn argument
  observeEvent(input$Hierarchy,{
    output$d3 <- renderD3tree({
      if(is.null(input$Hierarchy)){
        p=m
      }else{
        p=m%>%select(one_of(c(input$Hierarchy,"NEWCOL")))%>%unique
      }

      d3tree(data = list(root = df2tree(struct = p,rootname = 'm'), layout = 'collapse'),
             activeReturn = c("kingdom", "phylum", "class", "order", "family", "genus",
                              "species","counts", "database_name", "marker_name" ))
    })
  })

  observeEvent(network$nodes,{
    output$results <- renderPrint({
      str.out=''
      if(!is.null(network$nodes)) str.out=tree.filter(network$nodes,m)
      return(str.out)
    })
  })

  # Reactive table ----
  # Creates a filtered datatable, containing the selected nodes
  output$table <- DT::renderDataTable(expr = {
    TreeStruct()%>%select(-NEWCOL)
  },
  options=list(scrollX=T,title="Reactive Table")
  )

  # Grahps ----
  # Calculate coverage of each data set, based on the selected nodes
  output$billboarder <- renderBillboarder(expr = {
    dfActive <- TreeStruct()%>%select(-NEWCOL)
    nsrTotal <- unlist(lapply(dfActive[2:8], function(x) length(unique(x))))

    boldActive <- subset(dfActive,database_name=="BOLD")
    boldTotal <- unlist(lapply(boldActive[2:8], function(x) length(unique(x))))
    boldCov <- as.vector(round((boldTotal/nsrTotal * 100),1))

    natActive <- subset(dfActive,database_name=="NATURALIS")
    natTotal <- unlist(lapply(natActive[2:8], function(x) length(unique(x))))
    natCov <- as.vector(round((natTotal/nsrTotal * 100),1))

    combActive <- subset(dfActive,database_name=="BOLD" | database_name=="NATURALIS")
    combActive <- combActive[!duplicated(combActive$species),]
    combTotal <- unlist(lapply(combActive[2:8], function(x) length(unique(x))))
    combCov <- as.vector(round((combTotal/nsrTotal * 100),1))

    vis.cov <- data.frame(
      taxa = paste(names(dfActive)[2:8]),
      bold_total = boldCov,
      nat_total = natCov,
      comb_total = combCov
    )

    # Plot barchart for taxon coverage
    billboarder() %>%
      bb_barchart(
        data = vis.cov[, c("taxa", "bold_total", "nat_total", "comb_total")]
      ) %>%
      bb_data(
        names = list(bold_total = "bold", nat_total = "naturalis", comb_total = "combined")
      ) %>%
      bb_y_grid(show = TRUE) %>%
      bb_y_axis(tick = list(format = suffix("%")),
                label = list(text = "Percentage of taxa covered", position = "outer-top")) %>%
      bb_legend(position = "inset", inset = list(anchor = "top-right")) %>%
      bb_labs(title = "Coverage of taxa")
  })

  # Plot pie chart for share of markers
  output$markerPie <- renderBillboarder(expr = {
    dfActive <- TreeStruct()%>%select(-NEWCOL)
    vis.marker <- setNames(aggregate(dfActive$counts, list(dfActive$marker_name),
                                     FUN=sum), c("marker_name", "counts"))

    billboarder() %>%
      bb_piechart(data = vis.marker) %>%
      bb_labs(title = "Share of markers (BOLD)")
  })

}

shinyApp(ui, server)
```
