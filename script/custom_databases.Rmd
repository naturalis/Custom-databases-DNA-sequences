---
title: "Custom Databases Analyses"
author: "Bastiaan"
date: "11 January 2021"
output: html_document
---

Introduction
------------

The following R markdown file performs the steps needed to search out
and visualize overlap / gaps between obtained public sequence data
and its reference by the Dutch Species Register.

The following libraries need to be loaded:

```{r libraries, include=FALSE, message=FALSE, warning=FALSE}
library(rmarkdown)
library(taxizedb)
library(myTAI)
library(dplyr)
library(tidyr)
library(collapsibleTree)
library(shiny)
library(DT)
library(plyr)
library(dplyr)
library(d3Tree)
```

In addition, here We define the global variables that we will reuse throughout the code:

```{r globals, include=FALSE}
# This should define the root folder of the local copy of the git repository at: https://github.com/naturalis/Custom-databases-DNA-sequences, which is
# automatically defined correctly if we run the present code from within a
# local clone of the repo and have set the working directory to the script
# source (in RStudio: Session > Set working directory > To source file location)
REPO_HOME <- paste(dirname(getwd()), sep = "")
```

### Reference Data (NSR)

We now load the reference data for our tree. Ideally a full taxonomic
hierarchy of species from the NSR would be used as reference. As only the
scientific names has been given, classification of these species can be
extrated from a database of choice (ncbi, itis, gbif, bold).

```{r NSR, include=FALSE}
# Load species from the NSR file
NSR_Species <- sprintf('%s/data/NSR_exports/NSR_species.txt', REPO_HOME)
nsr_vec <- readLines(NSR_Species)

# Download taxonomic database	
# data source: NCBI	
db_download_ncbi()

# Convert NSR species names to NCBI taxon IDs
ncbi_taxid <- taxizedb::name2taxid(nsr_vec, db="ncbi", out_type="summary")
ncbi_in <- as.vector(ncbi_taxid$id)

# Retrieve taxonomic hierarchy for each taxon ID
ncbi_out <- taxizedb::classification(ncbi_in, db = "ncbi", row=1, verbose=FALSE)

# Parse out the taxonomy levels that you require
taxdata = data.frame()
for(x in 1:length(ncbi_out)){
    tryCatch({
      phylum=filter(ncbi_out[[x]], rank =="phylum")$name
      class=filter(ncbi_out[[x]], rank =="class")$name
      order=filter(ncbi_out[[x]], rank =="order")$name
      family=filter(ncbi_out[[x]], rank =="family")$name
      genus=filter(ncbi_out[[x]], rank =="genus")$name
      species=filter(ncbi_out[[x]], rank =="species")$name

      row <- data.frame(cbind(phylum=phylum,class=class,order=order,family=family,
                              genus=genus,species=species))
      taxdata <- bind_rows(taxdata, row)    
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
write.csv(taxdata, file=sprintf('%s/data/NSR_exports/taxdata-full.txt', REPO_HOME))
```

### Public Sequence Data (BOLD)

Subsequently, We load the list of taxa from our obtained public sequence
data from our [script](custom_databases.py).

```{r BOLD, include=FALSE}
# The location of the matching public sequence data
bold.file <- sprintf('%s/data/FASTA_files/match.fasta', REPO_HOME)

# Turn the file into a dataframe
df_bold <- read.csv(bold.file, sep = "\t", row.names=NULL)[c("phylum_name","class_name","order_name","family_name","genus_name","species_name","markercode")]

# Replace missing markers with NA
df_bold[df_bold==""]<-NA
```

### Calculations

Now we will reconcile the two data sets by adding the matching markercodes from the public dataset to the reference dataset and counting all duplicate rows, on the intersection of a common species name.

```{r Coverage, include=FALSE}
# Merge datasets, adding the public markers to the reference dataset
df_marker <- Reduce(function(x, y) merge(x, y, by.x=c("phylum","class","order","family","genus","species"), by.y=c("phylum_name","class_name","order_name","family_name","genus_name","species_name"), all.x=TRUE), list(taxdata, df_bold))

# Given multiple identical markers per species, count duplicates
df_coverage <- count(df_marker)

# Remove count for species not present in public dataset
df_coverage <- within(df_coverage, {
    f <- is.na(markercode) == TRUE
    freq[f] <- NA
})

# Cleanup; Drop boolean row and rename frequency of duplicate
df_coverage$f <- NULL
names(df_coverage)[length(names(df_coverage))]<-"count"
```

### Construct tree

Compute and draw reactive shiny filters through collapsible d3js tree

```{r include=FALSE}
m=df_coverage%>%data.frame%>%mutate(NEWCOL=NA)%>%distinct


ui <- fluidPage(
    fluidRow(
      column(6,
             uiOutput("Hierarchy"),
             tableOutput("clickView"),
             d3treeOutput(outputId="d3", height="800px")
      ),
      column(6,
             "Reactive Table",
             div(DT::dataTableOutput(outputId="table"),
                 style = "font-size:80%")
             )
      )
  )

server <- function(input, output, session) {
  
  #SearchTree----
  
  output$Hierarchy <- renderUI({
    Hierarchy=names(m)
    Hierarchy=head(Hierarchy,-1)
    selectizeInput("Hierarchy","Tree Hierarchy",
                   choices = Hierarchy,multiple=T,selected = Hierarchy,
                   options=list(plugins=list('drag_drop','remove_button')))
  })
  
  network <- reactiveValues()
  
  observeEvent(input$d3_update,{
    network$nodes <- unlist(input$d3_update$.nodesData)
    activeNode<-input$d3_update$.activeNode
    if(!is.null(activeNode)) network$click <- jsonlite::fromJSON(activeNode)
  })
  
  observeEvent(network$click,{
    output$clickView<-renderTable({
      as.data.frame(network$click)
    },caption='Last Clicked Node',caption.placement='top')
  })
 
  
  TreeStruct=eventReactive(network$nodes,{
    df=m
    if(is.null(network$nodes)){
      df=m
    }else{
      
      x.filter=tree.filter(network$nodes,m)
      df=ddply(x.filter,.(ID),function(a.x){m%>%filter_(.dots = list(a.x$FILTER))%>%distinct})
    }
    df
  })
  
  observeEvent(input$Hierarchy,{
    output$d3 <- renderD3tree({
      if(is.null(input$Hierarchy)){
        p=m
      }else{
        p=m%>%select(one_of(c(input$Hierarchy,"NEWCOL")))%>%unique
      }
      
     d3tree(data = list(root = df2tree(struct = p,rootname = 'm'), layout = 'collapse'),activeReturn = c("phylum", "class", "order", "family", "genus", "species", "markercode", "count"))
    })
})
  
  observeEvent(network$nodes,{
    output$results <- renderPrint({
      str.out=''
      if(!is.null(network$nodes)) str.out=tree.filter(network$nodes,m)
      return(str.out)
    })    
  })

  output$table <- DT::renderDataTable(expr = {
    TreeStruct()%>%select(-NEWCOL)
  },
  options=list(scrollX=T,title="Reactive Table")
  )
  
}
  
shinyApp(ui, server)
```